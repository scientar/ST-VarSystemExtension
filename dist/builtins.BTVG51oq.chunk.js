function e(){return[{id:'builtin-set',name:'SET',type:'active',enabled:!0,order:10,builtin:!0,description:'设置变量的值。语法: @.SET("path", value);',executor:'\n// SET(path, value) - 设置变量值\nconst [path, rawValue] = args;\n\n// 如果已经是对象/数组/数字等（parser 已解析），直接使用\nlet value = rawValue;\n\n// 如果是字符串，尝试解析\nif (typeof rawValue === \'string\') {\n  try {\n    value = JSON.parse(rawValue);\n  } catch (e) {\n    // 解析失败，去掉引号作为普通字符串\n    value = rawValue.replace(/^["\']|["\']$/g, \'\');\n  }\n}\n\n// 使用 lodash 的 set 方法\n_.set(snapshot, path, value);\n\nreturn snapshot;\n'},{id:'builtin-add',name:'ADD',type:'active',enabled:!0,order:20,builtin:!0,description:'数值加法或数组追加。如果目标是数组则追加，否则作数值加法。语法: @.ADD("path", value);',executor:'\n// ADD(path, value) - 数值加法或数组追加（兼容 MVU/SAM）\nconst [path, rawValue] = args;\n\n// 获取当前值\nconst currentValue = _.get(snapshot, path);\n\n// 如果是数组，追加元素（SAM 行为）\nif (Array.isArray(currentValue)) {\n  let value = rawValue;\n\n  // 如果是字符串，尝试解析\n  if (typeof rawValue === \'string\') {\n    try {\n      value = JSON.parse(rawValue);\n    } catch (e) {\n      value = rawValue.replace(/^["\']|["\']$/g, \'\');\n    }\n  }\n\n  currentValue.push(value);\n  _.set(snapshot, path, currentValue);\n  return snapshot;\n}\n\n// 否则作为数值加法（MVU 行为）\nlet num;\nif (typeof rawValue === \'number\') {\n  num = rawValue;\n} else if (typeof rawValue === \'string\') {\n  num = parseFloat(rawValue);\n} else {\n  num = NaN;\n}\n\nif (isNaN(num)) {\n  console.warn(\'[ST-VarSystem] ADD: 无效的数值参数:\', rawValue);\n  return snapshot;\n}\n\nconst newValue = (parseFloat(currentValue) || 0) + num;\n_.set(snapshot, path, newValue);\n\nreturn snapshot;\n'},{id:'builtin-sub',name:'SUB',type:'active',enabled:!0,order:30,builtin:!0,description:'数值减法。语法: @.SUB("path", number);',executor:'\n// SUB(path, number) - 数值减法\nconst [path, numStr] = args;\nconst num = parseFloat(numStr);\n\nif (isNaN(num)) {\n  console.warn(\'[ST-VarSystem] SUB: 无效的数值参数:\', numStr);\n  return snapshot;\n}\n\nconst currentValue = _.get(snapshot, path, 0);\nconst newValue = (parseFloat(currentValue) || 0) - num;\n_.set(snapshot, path, newValue);\n\nreturn snapshot;\n'},{id:'builtin-del',name:'DEL',type:'active',enabled:!0,order:35,builtin:!0,description:'删除数组中指定索引的元素。语法: @.DEL("path", index);',executor:'\n// DEL(path, index) - 删除数组元素（SAM）\nconst [path, indexStr] = args;\nconst index = parseInt(indexStr);\n\nif (isNaN(index) || index < 0) {\n  console.warn(\'[ST-VarSystem] DEL: 无效的索引:\', indexStr);\n  return snapshot;\n}\n\nconst arr = _.get(snapshot, path);\nif (!Array.isArray(arr)) {\n  console.warn(\'[ST-VarSystem] DEL: 目标不是数组:\', path);\n  return snapshot;\n}\n\nif (index >= arr.length) {\n  console.warn(\'[ST-VarSystem] DEL: 索引超出范围:\', index);\n  return snapshot;\n}\n\narr.splice(index, 1);\n_.set(snapshot, path, arr);\n\nreturn snapshot;\n'},{id:'builtin-append',name:'APPEND',type:'active',enabled:!0,order:40,builtin:!0,description:'向数组末尾追加元素。语法: @.APPEND("path", value);',executor:'\n// APPEND(path, value) - 数组追加（MVU）\nconst [path, rawValue] = args;\n\n// 如果已经是对象/数组/数字等（parser 已解析），直接使用\nlet value = rawValue;\n\n// 如果是字符串，尝试解析\nif (typeof rawValue === \'string\') {\n  try {\n    value = JSON.parse(rawValue);\n  } catch (e) {\n    value = rawValue.replace(/^["\']|["\']$/g, \'\');\n  }\n}\n\n// 获取当前数组\nlet arr = _.get(snapshot, path);\n\n// 如果不存在或不是数组，创建新数组\nif (!Array.isArray(arr)) {\n  arr = [];\n}\n\narr.push(value);\n_.set(snapshot, path, arr);\n\nreturn snapshot;\n'},{id:'builtin-remove',name:'REMOVE',type:'active',enabled:!0,order:50,builtin:!0,description:'从数组中移除元素（按索引或值）。语法: @.REMOVE("path", indexOrValue);',executor:'\n// REMOVE(path, indexOrValue) - 数组删除（MVU）\nconst [path, rawValue] = args;\n\n// 获取当前数组\nlet arr = _.get(snapshot, path);\n\nif (!Array.isArray(arr)) {\n  console.warn(\'[ST-VarSystem] REMOVE: 目标不是数组:\', path);\n  return snapshot;\n}\n\n// 尝试解析为索引（数字）\nlet index;\nif (typeof rawValue === \'number\') {\n  index = rawValue;\n} else if (typeof rawValue === \'string\') {\n  index = parseInt(rawValue);\n} else {\n  index = NaN;\n}\n\nif (!isNaN(index) && index >= 0 && index < arr.length) {\n  // 按索引删除\n  arr.splice(index, 1);\n} else {\n  // 按值删除\n  let value = rawValue;\n\n  // 如果是字符串，尝试解析\n  if (typeof rawValue === \'string\') {\n    try {\n      value = JSON.parse(rawValue);\n    } catch (e) {\n      value = rawValue.replace(/^["\']|["\']$/g, \'\');\n    }\n  }\n\n  const idx = arr.indexOf(value);\n  if (idx !== -1) {\n    arr.splice(idx, 1);\n  }\n}\n\n_.set(snapshot, path, arr);\n\nreturn snapshot;\n'},{id:'builtin-select-set',name:'SELECT_SET',type:'active',enabled:!0,order:60,builtin:!0,description:'在数组中查找对象并设置其属性。语法: @.SELECT_SET("path", "selectorKey", "selectorValue", "receiverKey", newValue);',executor:'\n// SELECT_SET(path, selectorKey, selectorValue, receiverKey, newValue) - SAM\nconst [path, selectorKey, selectorValue, receiverKey, rawNewValue] = args;\n\nconst arr = _.get(snapshot, path);\nif (!Array.isArray(arr)) {\n  console.warn(\'[ST-VarSystem] SELECT_SET: 目标不是数组:\', path);\n  return snapshot;\n}\n\n// 解析新值（如果已经是对象/数组/数字等，直接使用）\nlet newValue = rawNewValue;\n\nif (typeof rawNewValue === \'string\') {\n  try {\n    newValue = JSON.parse(rawNewValue);\n  } catch (e) {\n    newValue = rawNewValue.replace(/^["\']|["\']$/g, \'\');\n  }\n}\n\n// 查找匹配的对象\nconst targetObj = arr.find(item =>\n  item && typeof item === \'object\' && item[selectorKey] === selectorValue\n);\n\nif (targetObj) {\n  targetObj[receiverKey] = newValue;\n} else {\n  console.warn(`[ST-VarSystem] SELECT_SET: 未找到匹配对象 ${selectorKey}=${selectorValue}`);\n}\n\nreturn snapshot;\n'},{id:'builtin-select-add',name:'SELECT_ADD',type:'active',enabled:!0,order:70,builtin:!0,description:'在数组中查找对象并增加其属性值。语法: @.SELECT_ADD("path", "selectorKey", "selectorValue", "receiverKey", valueToAdd);',executor:'\n// SELECT_ADD(path, selectorKey, selectorValue, receiverKey, valueToAdd) - SAM\nconst [path, selectorKey, selectorValue, receiverKey, rawValueToAdd] = args;\n\nconst arr = _.get(snapshot, path);\nif (!Array.isArray(arr)) {\n  console.warn(\'[ST-VarSystem] SELECT_ADD: 目标不是数组:\', path);\n  return snapshot;\n}\n\n// 查找匹配的对象\nconst targetObj = arr.find(item =>\n  item && typeof item === \'object\' && item[selectorKey] === selectorValue\n);\n\nif (!targetObj) {\n  console.warn(`[ST-VarSystem] SELECT_ADD: 未找到匹配对象 ${selectorKey}=${selectorValue}`);\n  return snapshot;\n}\n\nconst currentValue = targetObj[receiverKey];\n\n// 如果是数组，追加元素\nif (Array.isArray(currentValue)) {\n  let value = rawValueToAdd;\n\n  // 如果是字符串，尝试解析\n  if (typeof rawValueToAdd === \'string\') {\n    try {\n      value = JSON.parse(rawValueToAdd);\n    } catch (e) {\n      value = rawValueToAdd.replace(/^["\']|["\']$/g, \'\');\n    }\n  }\n\n  currentValue.push(value);\n} else {\n  // 否则作为数值加法\n  let num;\n  if (typeof rawValueToAdd === \'number\') {\n    num = rawValueToAdd;\n  } else if (typeof rawValueToAdd === \'string\') {\n    num = parseFloat(rawValueToAdd);\n  } else {\n    num = NaN;\n  }\n\n  if (isNaN(num)) {\n    console.warn(\'[ST-VarSystem] SELECT_ADD: 无效的数值参数:\', rawValueToAdd);\n    return snapshot;\n  }\n  targetObj[receiverKey] = (parseFloat(currentValue) || 0) + num;\n}\n\nreturn snapshot;\n'},{id:'builtin-select-del',name:'SELECT_DEL',type:'active',enabled:!0,order:80,builtin:!0,description:'在数组中查找并删除匹配的对象。语法: @.SELECT_DEL("path", "selectorKey", "selectorValue");',executor:'\n// SELECT_DEL(path, selectorKey, selectorValue) - SAM\nconst [path, selectorKey, selectorValue] = args;\n\nconst arr = _.get(snapshot, path);\nif (!Array.isArray(arr)) {\n  console.warn(\'[ST-VarSystem] SELECT_DEL: 目标不是数组:\', path);\n  return snapshot;\n}\n\n// 查找匹配对象的索引\nconst index = arr.findIndex(item => \n  item && typeof item === \'object\' && item[selectorKey] === selectorValue\n);\n\nif (index !== -1) {\n  arr.splice(index, 1);\n} else {\n  console.warn(`[ST-VarSystem] SELECT_DEL: 未找到匹配对象 ${selectorKey}=${selectorValue}`);\n}\n\nreturn snapshot;\n'},{id:'builtin-inc',name:'INC',type:'active',enabled:!0,order:90,builtin:!0,description:'数值自增（默认 +1）。语法: @.INC("path") 或 @.INC("path", step);',executor:'\n// INC(path, step?) - 数值自增（MVU）\nconst [path, stepStr] = args;\nconst step = stepStr ? parseFloat(stepStr) : 1;\n\nif (isNaN(step)) {\n  console.warn(\'[ST-VarSystem] INC: 无效的步进值:\', stepStr);\n  return snapshot;\n}\n\nconst currentValue = _.get(snapshot, path, 0);\nconst newValue = (parseFloat(currentValue) || 0) + step;\n_.set(snapshot, path, newValue);\n\nreturn snapshot;\n'},{id:'builtin-dec',name:'DEC',type:'active',enabled:!0,order:100,builtin:!0,description:'数值自减（默认 -1）。语法: @.DEC("path") 或 @.DEC("path", step);',executor:'\n// DEC(path, step?) - 数值自减（MVU）\nconst [path, stepStr] = args;\nconst step = stepStr ? parseFloat(stepStr) : 1;\n\nif (isNaN(step)) {\n  console.warn(\'[ST-VarSystem] DEC: 无效的步进值:\', stepStr);\n  return snapshot;\n}\n\nconst currentValue = _.get(snapshot, path, 0);\nconst newValue = (parseFloat(currentValue) || 0) - step;\n_.set(snapshot, path, newValue);\n\nreturn snapshot;\n'},{id:'builtin-delete',name:'DELETE',type:'active',enabled:!0,order:110,builtin:!0,description:'删除变量。语法: @.DELETE("path");',executor:'\n// DELETE(path) - 删除变量（MVU）\nconst [path] = args;\n\n_.unset(snapshot, path);\n\nreturn snapshot;\n'}]}function n(e){const n=[{id:'builtin-set',name:'SET',type:'active',enabled:!0,order:10,builtin:!0,description:'设置变量的值。语法: @.SET("path", value);',executor:'\n// SET(path, value) - 设置变量值\nconst [path, rawValue] = args;\n\n// 如果已经是对象/数组/数字等（parser 已解析），直接使用\nlet value = rawValue;\n\n// 如果是字符串，尝试解析\nif (typeof rawValue === \'string\') {\n  try {\n    value = JSON.parse(rawValue);\n  } catch (e) {\n    // 解析失败，去掉引号作为普通字符串\n    value = rawValue.replace(/^["\']|["\']$/g, \'\');\n  }\n}\n\n// 使用 lodash 的 set 方法\n_.set(snapshot, path, value);\n\nreturn snapshot;\n'},{id:'builtin-add',name:'ADD',type:'active',enabled:!0,order:20,builtin:!0,description:'数值加法或数组追加。如果目标是数组则追加，否则作数值加法。语法: @.ADD("path", value);',executor:'\n// ADD(path, value) - 数值加法或数组追加（兼容 MVU/SAM）\nconst [path, rawValue] = args;\n\n// 获取当前值\nconst currentValue = _.get(snapshot, path);\n\n// 如果是数组，追加元素（SAM 行为）\nif (Array.isArray(currentValue)) {\n  let value = rawValue;\n\n  // 如果是字符串，尝试解析\n  if (typeof rawValue === \'string\') {\n    try {\n      value = JSON.parse(rawValue);\n    } catch (e) {\n      value = rawValue.replace(/^["\']|["\']$/g, \'\');\n    }\n  }\n\n  currentValue.push(value);\n  _.set(snapshot, path, currentValue);\n  return snapshot;\n}\n\n// 否则作为数值加法（MVU 行为）\nlet num;\nif (typeof rawValue === \'number\') {\n  num = rawValue;\n} else if (typeof rawValue === \'string\') {\n  num = parseFloat(rawValue);\n} else {\n  num = NaN;\n}\n\nif (isNaN(num)) {\n  console.warn(\'[ST-VarSystem] ADD: 无效的数值参数:\', rawValue);\n  return snapshot;\n}\n\nconst newValue = (parseFloat(currentValue) || 0) + num;\n_.set(snapshot, path, newValue);\n\nreturn snapshot;\n'},{id:'builtin-sub',name:'SUB',type:'active',enabled:!0,order:30,builtin:!0,description:'数值减法。语法: @.SUB("path", number);',executor:'\n// SUB(path, number) - 数值减法\nconst [path, numStr] = args;\nconst num = parseFloat(numStr);\n\nif (isNaN(num)) {\n  console.warn(\'[ST-VarSystem] SUB: 无效的数值参数:\', numStr);\n  return snapshot;\n}\n\nconst currentValue = _.get(snapshot, path, 0);\nconst newValue = (parseFloat(currentValue) || 0) - num;\n_.set(snapshot, path, newValue);\n\nreturn snapshot;\n'},{id:'builtin-del',name:'DEL',type:'active',enabled:!0,order:35,builtin:!0,description:'删除数组中指定索引的元素。语法: @.DEL("path", index);',executor:'\n// DEL(path, index) - 删除数组元素（SAM）\nconst [path, indexStr] = args;\nconst index = parseInt(indexStr);\n\nif (isNaN(index) || index < 0) {\n  console.warn(\'[ST-VarSystem] DEL: 无效的索引:\', indexStr);\n  return snapshot;\n}\n\nconst arr = _.get(snapshot, path);\nif (!Array.isArray(arr)) {\n  console.warn(\'[ST-VarSystem] DEL: 目标不是数组:\', path);\n  return snapshot;\n}\n\nif (index >= arr.length) {\n  console.warn(\'[ST-VarSystem] DEL: 索引超出范围:\', index);\n  return snapshot;\n}\n\narr.splice(index, 1);\n_.set(snapshot, path, arr);\n\nreturn snapshot;\n'},{id:'builtin-append',name:'APPEND',type:'active',enabled:!0,order:40,builtin:!0,description:'向数组末尾追加元素。语法: @.APPEND("path", value);',executor:'\n// APPEND(path, value) - 数组追加（MVU）\nconst [path, rawValue] = args;\n\n// 如果已经是对象/数组/数字等（parser 已解析），直接使用\nlet value = rawValue;\n\n// 如果是字符串，尝试解析\nif (typeof rawValue === \'string\') {\n  try {\n    value = JSON.parse(rawValue);\n  } catch (e) {\n    value = rawValue.replace(/^["\']|["\']$/g, \'\');\n  }\n}\n\n// 获取当前数组\nlet arr = _.get(snapshot, path);\n\n// 如果不存在或不是数组，创建新数组\nif (!Array.isArray(arr)) {\n  arr = [];\n}\n\narr.push(value);\n_.set(snapshot, path, arr);\n\nreturn snapshot;\n'},{id:'builtin-remove',name:'REMOVE',type:'active',enabled:!0,order:50,builtin:!0,description:'从数组中移除元素（按索引或值）。语法: @.REMOVE("path", indexOrValue);',executor:'\n// REMOVE(path, indexOrValue) - 数组删除（MVU）\nconst [path, rawValue] = args;\n\n// 获取当前数组\nlet arr = _.get(snapshot, path);\n\nif (!Array.isArray(arr)) {\n  console.warn(\'[ST-VarSystem] REMOVE: 目标不是数组:\', path);\n  return snapshot;\n}\n\n// 尝试解析为索引（数字）\nlet index;\nif (typeof rawValue === \'number\') {\n  index = rawValue;\n} else if (typeof rawValue === \'string\') {\n  index = parseInt(rawValue);\n} else {\n  index = NaN;\n}\n\nif (!isNaN(index) && index >= 0 && index < arr.length) {\n  // 按索引删除\n  arr.splice(index, 1);\n} else {\n  // 按值删除\n  let value = rawValue;\n\n  // 如果是字符串，尝试解析\n  if (typeof rawValue === \'string\') {\n    try {\n      value = JSON.parse(rawValue);\n    } catch (e) {\n      value = rawValue.replace(/^["\']|["\']$/g, \'\');\n    }\n  }\n\n  const idx = arr.indexOf(value);\n  if (idx !== -1) {\n    arr.splice(idx, 1);\n  }\n}\n\n_.set(snapshot, path, arr);\n\nreturn snapshot;\n'},{id:'builtin-select-set',name:'SELECT_SET',type:'active',enabled:!0,order:60,builtin:!0,description:'在数组中查找对象并设置其属性。语法: @.SELECT_SET("path", "selectorKey", "selectorValue", "receiverKey", newValue);',executor:'\n// SELECT_SET(path, selectorKey, selectorValue, receiverKey, newValue) - SAM\nconst [path, selectorKey, selectorValue, receiverKey, rawNewValue] = args;\n\nconst arr = _.get(snapshot, path);\nif (!Array.isArray(arr)) {\n  console.warn(\'[ST-VarSystem] SELECT_SET: 目标不是数组:\', path);\n  return snapshot;\n}\n\n// 解析新值（如果已经是对象/数组/数字等，直接使用）\nlet newValue = rawNewValue;\n\nif (typeof rawNewValue === \'string\') {\n  try {\n    newValue = JSON.parse(rawNewValue);\n  } catch (e) {\n    newValue = rawNewValue.replace(/^["\']|["\']$/g, \'\');\n  }\n}\n\n// 查找匹配的对象\nconst targetObj = arr.find(item =>\n  item && typeof item === \'object\' && item[selectorKey] === selectorValue\n);\n\nif (targetObj) {\n  targetObj[receiverKey] = newValue;\n} else {\n  console.warn(`[ST-VarSystem] SELECT_SET: 未找到匹配对象 ${selectorKey}=${selectorValue}`);\n}\n\nreturn snapshot;\n'},{id:'builtin-select-add',name:'SELECT_ADD',type:'active',enabled:!0,order:70,builtin:!0,description:'在数组中查找对象并增加其属性值。语法: @.SELECT_ADD("path", "selectorKey", "selectorValue", "receiverKey", valueToAdd);',executor:'\n// SELECT_ADD(path, selectorKey, selectorValue, receiverKey, valueToAdd) - SAM\nconst [path, selectorKey, selectorValue, receiverKey, rawValueToAdd] = args;\n\nconst arr = _.get(snapshot, path);\nif (!Array.isArray(arr)) {\n  console.warn(\'[ST-VarSystem] SELECT_ADD: 目标不是数组:\', path);\n  return snapshot;\n}\n\n// 查找匹配的对象\nconst targetObj = arr.find(item =>\n  item && typeof item === \'object\' && item[selectorKey] === selectorValue\n);\n\nif (!targetObj) {\n  console.warn(`[ST-VarSystem] SELECT_ADD: 未找到匹配对象 ${selectorKey}=${selectorValue}`);\n  return snapshot;\n}\n\nconst currentValue = targetObj[receiverKey];\n\n// 如果是数组，追加元素\nif (Array.isArray(currentValue)) {\n  let value = rawValueToAdd;\n\n  // 如果是字符串，尝试解析\n  if (typeof rawValueToAdd === \'string\') {\n    try {\n      value = JSON.parse(rawValueToAdd);\n    } catch (e) {\n      value = rawValueToAdd.replace(/^["\']|["\']$/g, \'\');\n    }\n  }\n\n  currentValue.push(value);\n} else {\n  // 否则作为数值加法\n  let num;\n  if (typeof rawValueToAdd === \'number\') {\n    num = rawValueToAdd;\n  } else if (typeof rawValueToAdd === \'string\') {\n    num = parseFloat(rawValueToAdd);\n  } else {\n    num = NaN;\n  }\n\n  if (isNaN(num)) {\n    console.warn(\'[ST-VarSystem] SELECT_ADD: 无效的数值参数:\', rawValueToAdd);\n    return snapshot;\n  }\n  targetObj[receiverKey] = (parseFloat(currentValue) || 0) + num;\n}\n\nreturn snapshot;\n'},{id:'builtin-select-del',name:'SELECT_DEL',type:'active',enabled:!0,order:80,builtin:!0,description:'在数组中查找并删除匹配的对象。语法: @.SELECT_DEL("path", "selectorKey", "selectorValue");',executor:'\n// SELECT_DEL(path, selectorKey, selectorValue) - SAM\nconst [path, selectorKey, selectorValue] = args;\n\nconst arr = _.get(snapshot, path);\nif (!Array.isArray(arr)) {\n  console.warn(\'[ST-VarSystem] SELECT_DEL: 目标不是数组:\', path);\n  return snapshot;\n}\n\n// 查找匹配对象的索引\nconst index = arr.findIndex(item => \n  item && typeof item === \'object\' && item[selectorKey] === selectorValue\n);\n\nif (index !== -1) {\n  arr.splice(index, 1);\n} else {\n  console.warn(`[ST-VarSystem] SELECT_DEL: 未找到匹配对象 ${selectorKey}=${selectorValue}`);\n}\n\nreturn snapshot;\n'},{id:'builtin-inc',name:'INC',type:'active',enabled:!0,order:90,builtin:!0,description:'数值自增（默认 +1）。语法: @.INC("path") 或 @.INC("path", step);',executor:'\n// INC(path, step?) - 数值自增（MVU）\nconst [path, stepStr] = args;\nconst step = stepStr ? parseFloat(stepStr) : 1;\n\nif (isNaN(step)) {\n  console.warn(\'[ST-VarSystem] INC: 无效的步进值:\', stepStr);\n  return snapshot;\n}\n\nconst currentValue = _.get(snapshot, path, 0);\nconst newValue = (parseFloat(currentValue) || 0) + step;\n_.set(snapshot, path, newValue);\n\nreturn snapshot;\n'},{id:'builtin-dec',name:'DEC',type:'active',enabled:!0,order:100,builtin:!0,description:'数值自减（默认 -1）。语法: @.DEC("path") 或 @.DEC("path", step);',executor:'\n// DEC(path, step?) - 数值自减（MVU）\nconst [path, stepStr] = args;\nconst step = stepStr ? parseFloat(stepStr) : 1;\n\nif (isNaN(step)) {\n  console.warn(\'[ST-VarSystem] DEC: 无效的步进值:\', stepStr);\n  return snapshot;\n}\n\nconst currentValue = _.get(snapshot, path, 0);\nconst newValue = (parseFloat(currentValue) || 0) - step;\n_.set(snapshot, path, newValue);\n\nreturn snapshot;\n'},{id:'builtin-delete',name:'DELETE',type:'active',enabled:!0,order:110,builtin:!0,description:'删除变量。语法: @.DELETE("path");',executor:'\n// DELETE(path) - 删除变量（MVU）\nconst [path] = args;\n\n_.unset(snapshot, path);\n\nreturn snapshot;\n'}];for(const a of n)e.upsertGlobalFunction(a);console.log('[ST-VarSystemExtension] 已注册',n.length,'个内置函数'),console.log('[ST-VarSystemExtension] MVU 兼容函数: SET, ADD, SUB, APPEND, REMOVE, INC, DEC, DELETE'),console.log('[ST-VarSystemExtension] SAM 兼容函数: SET, ADD, DEL, SELECT_SET, SELECT_ADD, SELECT_DEL')}export{e as getBuiltinFunctions,n as initBuiltinFunctions};
//# sourceMappingURL=builtins.BTVG51oq.chunk.js.map
